import { useState, useEffect } from 'react';
import { backendWalletService, BackendWallet } from '../services/backendWallet';
import { ethers } from 'ethers';
import { useSelector } from 'react-redux';
import { RootState } from '../services/store';

export const useBackendWallet = () => {
  const [isConnected, setIsConnected] = useState(false);
  const [address, setAddress] = useState<string | null>(null);
  const [balances, setBalances] = useState<Record<string, number>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingBalances, setIsLoadingBalances] = useState(false);
  
  // Get wallet address from user profile state (generated by backend)
  const profile = useSelector((state: RootState) => state.user.profile);
  const walletAddress = profile?.walletAddress;
  console.log('walletAddress', walletAddress);

  // Popular BSC tokens to show with 0 balances when wallet is empty
  const POPULAR_BSC_FALLBACK = [
    { symbol: 'BNB', name: 'BNB', address: 'native', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png', balance: 0 },
    { symbol: 'USDT', name: 'Tether USD', address: '0x55d398326f99059fF775485246999027B3197955', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/325/small/Tether.png', balance: 0 },
    { symbol: 'USDC', name: 'USD Coin', address: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png', balance: 0 },
    { symbol: 'BUSD', name: 'Binance USD', address: '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/9576/small/BUSD.png', balance: 0 },
    { symbol: 'ETH', name: 'Ethereum Token', address: '0x2170Ed0880ac9A755fd29B2688956BD959F933F8', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png', balance: 0 },
    { symbol: 'BTCB', name: 'Bitcoin BEP2', address: '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/7598/small/wrapped_bitcoin_wbtc.png', balance: 0 },
    { symbol: 'CAKE', name: 'PancakeSwap Token', address: '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/12632/small/pancakeswap-cake-logo_%281%29.png', balance: 0 }
  ];

  // Fetch token list from PancakeSwap API
  const fetchTokenList = async () => {
    try {
      const response = await fetch('https://tokens.pancakeswap.finance/pancakeswap-bnb-mm.json');
      const data = await response.json();
      
      // Convert to our format and add native BNB
      const tokens = data.tokens.map((token: any) => ({
        symbol: token.symbol,
        name: token.name,
        address: token.address,
        decimals: token.decimals,
        logoURI: token.logoURI
      }));
      
      // Add native BNB
      tokens.unshift({
        symbol: 'BNB',
        name: 'BNB',
        address: 'native',
        decimals: 18,
        logoURI: 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png'
      });
      
      return tokens;
    } catch (error) {
      console.error('Failed to fetch token list:', error);
      // Fallback to basic tokens
      return [
        { symbol: 'BNB', name: 'BNB', address: 'native', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png' },
        { symbol: 'USDT', name: 'Tether USD', address: '0x55d398326f99059fF775485246999027B3197955', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/325/small/Tether.png' },
        { symbol: 'USDC', name: 'USD Coin', address: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png' },
        { symbol: 'BUSD', name: 'Binance USD', address: '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/9576/small/BUSD.png' },
        { symbol: 'ETH', name: 'Ethereum Token', address: '0x2170Ed0880ac9A755fd29B2688956BD959F933F8', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
        { symbol: 'BTCB', name: 'Bitcoin BEP2', address: '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c', decimals: 18, logoURI: 'https://assets.coingecko.com/coins/images/7598/small/wrapped_bitcoin_wbtc.png' }
      ];
    }
  };

  // Fetch real balances from BSC with dynamic token detection
  const fetchRealBalances = async () => {
    if (!address) {
      setIsLoadingBalances(false);
      return;
    }
    
    setIsLoadingBalances(true);
    console.log('Starting balance fetch for address:', address);
    
    // Set a timeout to prevent infinite loading
    const timeoutId = setTimeout(() => {
      console.warn('Balance fetch timeout, setting loading to false');
      setIsLoadingBalances(false);
      setBalances({});
    }, 20000); // 20 second timeout - reduced to prevent long waits
    
    try {
      // Fetch token list from PancakeSwap with timeout
      const tokenListPromise = fetchTokenList();
      const tokenListTimeout = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Token list fetch timeout')), 10000)
      );
      
      const tokenList = await Promise.race([tokenListPromise, tokenListTimeout]) as any[];
      console.log('Fetched token list:', tokenList.length, 'tokens');
      
      // Use a reliable BSC RPC endpoint
      const provider = new ethers.JsonRpcProvider('https://bsc-dataseed.binance.org/');
      
      // Test connection first with timeout
      try {
        await Promise.race([
          provider.getBlockNumber(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('RPC timeout')), 5000))
        ]);
        console.log('Connected to BSC RPC');
      } catch (error) {
        console.error('Failed to connect to BSC RPC:', error);
        throw new Error('Failed to connect to blockchain');
      }
      
      const newBalances: Record<string, number> = {};
      const ERC20_ABI = [
        "function balanceOf(address) view returns (uint256)",
        "function decimals() view returns (uint8)"
      ];
      
      // Process tokens in batches to avoid overwhelming the RPC
      const batchSize = 5; // Reduced batch size
      const maxBatches = 4; // Limit to first 20 tokens to prevent timeout
      const tokensToCheck = tokenList.slice(0, batchSize * maxBatches);
      
      for (let i = 0; i < tokensToCheck.length; i += batchSize) {
        const batch = tokensToCheck.slice(i, i + batchSize);
        
        // Add timeout for each batch
        const batchPromise = Promise.all(batch.map(async (token: any) => {
          try {
            let balance = 0;
            
            if (token.address === 'native') {
              // Fetch BNB balance with timeout
              const bnbBalance = await Promise.race([
                provider.getBalance(address),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 3000))
              ]) as bigint;
              balance = Number(ethers.formatEther(bnbBalance));
            } else {
              // Fetch ERC20 token balance with timeout
              const contract = new ethers.Contract(token.address, ERC20_ABI, provider);
              const [rawBalance, decimals] = await Promise.race([
                Promise.all([
                  contract.balanceOf(address),
                  contract.decimals()
                ]),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 3000))
              ]) as [bigint, number];
              balance = Number(ethers.formatUnits(rawBalance, decimals));
            }
            
            // Only store tokens with balance > 0
            if (balance > 0) {
              newBalances[token.symbol] = balance;
              console.log(`${token.symbol} balance:`, balance);
            }
          } catch (error) {
            console.warn(`Failed to fetch balance for ${token.symbol}:`, error);
          }
        }));
        
        await batchPromise;
        
        // Small delay between batches to avoid rate limiting
        if (i + batchSize < tokensToCheck.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      // Always show popular BSC tokens, merge with real balances
      const allTokenBalances = POPULAR_BSC_FALLBACK.reduce((acc, token) => {
        acc[token.symbol] = newBalances[token.symbol] || 0;
        return acc;
      }, {} as Record<string, number>);
      
      console.log('Final balances (popular BSC tokens):', allTokenBalances);
      setBalances(allTokenBalances);
      backendWalletService.setBalances(allTokenBalances);
      
      clearTimeout(timeoutId);
    } catch (error) {
      console.error('Failed to fetch balances:', error);
      setBalances({});
      clearTimeout(timeoutId);
    } finally {
      setIsLoadingBalances(false);
    }
  };

  // Initialize wallet connection
  const connectWallet = async () => {
    setIsLoading(true);
    try {
      // Check if wallet address is available in profile
      if (!walletAddress) {
        console.warn('No wallet address found in user profile');
        setIsLoading(false);
        return;
      }

      // Use the wallet address from user profile
      const wallet: BackendWallet = {
        address: walletAddress,
        // privateKey: "backend-managed", // This would be encrypted in production
        // mnemonic: "backend-managed" // This would be encrypted in production
      };
      
      backendWalletService.setWallet(wallet);
      setIsConnected(true);
      setAddress(wallet.address);
      
      // Fetch real balances from BSC
      await fetchRealBalances();
      
    } catch (error) {
      console.error('Failed to connect wallet:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Disconnect wallet
  const disconnect = () => {
    backendWalletService.clearWallet();
    setIsConnected(false);
    setAddress(null);
    setBalances({});
  };

  // Get token balances
  const getTokenBalances = async () => {
    if (isConnected && address && !isLoadingBalances) {
      await fetchRealBalances();
    }
    return balances;
  };

  // Get custom tokens
  const getCustomTokens = () => {
    return backendWalletService.getCustomTokens();
  };

  // Get available tokens (popular BSC tokens with real balances)
  const getAvailableTokens = () => {
    return POPULAR_BSC_FALLBACK.map(token => ({
      symbol: token.symbol,
      balance: balances[token.symbol] || 0,
      name: token.name,
      address: token.address,
      logoURI: token.logoURI,
      isReal: true // All are real BSC tokens
    }));
  };

  // Import token (simplified for backend)
  const importToken = async () => {
    // In real implementation, this would save to backend
    return true;
  };

  // Auto-connect wallet when wallet address is available
  useEffect(() => {
    const autoConnect = async () => {
      if (walletAddress && !isConnected && !isLoading) {
        await connectWallet();
      }
    };
    
    autoConnect();
  }, [walletAddress]); // Depend on walletAddress from profile


  return {
    isConnected,
    address,
    balances,
    isLoading,
    isLoadingBalances,
    connectWallet,
    disconnect,
    getTokenBalances,
    getCustomTokens,
    getAvailableTokens,
    importToken,
  };
};
